



Network Working Group                                            D. Wing
Internet-Draft                                                    Citrix
Intended status: Standards Track                        24 December 2024
Expires: 27 June 2025


                   Public Key Hash for Local Domains
                draft-wing-settle-public-key-hash-latest

Abstract

   This specification eliminates security warnings when connecting to
   local domains using TLS.  Servers use a long hostname which encodes
   their public key that the client validates against the public key
   presented in the TLS handshake.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://danwing.github.io/public-key-hash/draft-wing-settle-public-
   key-hash.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-wing-settle-public-key-hash/.

   Discussion of this document takes place on the SETTLE mailing list
   (mailto:settle@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/settle/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/settle/.

   Source for this draft and an issue tracker can be found at
   https://github.com/danwing/public-key-hash.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 27 June 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Operation
     2.1.  Client Operation
     2.2.  Server Operation
   3.  Unique Host Names
   4.  Short Host Names
   5.  Validation
   6.  Encoding Details
   7.  Identifying Servers as Local
     7.1.  Local Domain Names
     7.2.  Local IP Addresses
   8.  Security Considerations
     8.1.  Rogue Servers on Local Domain
     8.2.  Public Key Hash
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Example Encoding
   Acknowledgments
   Author's Address

1.  Introduction

   Browsers are progressively reducing the capabilities and features
   that are available to origins that use unsecured HTTP.  In
   particular, new features are being developed exclusively for HTTPS
   origins which require CA-signed certificates ([secure-context]).
   However, obtaining CA-signed certificates is difficult for servers
   operating in local domains because the local domains prohibit
   incoming connections and because the local domain does not already
   have its own public domain name.

   This draft discusses how a client can authenticate to HTTPS servers
   belonging to the local domain where the server name is a hash of the
   server's public key.  This avoids the need for a certificate signed
   by a Certification Authority (CA) trusted by the client.  This is a
   relaxed way of "doing HTTPS" for servers on the local domain.

2.  Operation

2.1.  Client Operation

   When clients connect to such a local domain name or IP address
   (Section 7) using TLS they examine if the domain name starts with a
   registered hash identifier in the second label and if the rest of
   that label consists of an appropriate-length encoded hash.  If those
   conditions apply, the client MAY send a TLS ClientHello with the Raw
   Public Key extension [RFC7250].  When the client receives the
   server's raw public key or certificate, the client checks if the hash
   matches the public key received in the TLS ServerHello.  If they
   match, the client authenticates the TLS connection.  If they do not
   match, the client behavior falls back to the client's normal handling
   of the presented TLS raw public key or certificate (which may well be
   valid).

2.2.  Server Operation

   A server running on a local network (see Section 3) uses a unique
   host name that includes a hash of its public key.  This unique name
   is encoded as described in Section 6, and might even be configurable
   on existing servers (without software changes).

3.  Unique Host Names

   Web browsers and other application clients store per-host state using
   the host name, including cached form data such as passwords,
   integrated and 3rd party password managers, cookies, and other data.
   When a name collision occurs (e.g., the same printer.local name on
   two different networks) the client cannot recognize a different host
   is being encountered.  While it is possible to extend all of these
   clients to extend their index to include the server's public key,
   this seems to lack business justification for the engineering effort
   to solely improve the user experience (short name, Section 4) on
   local networks.

   A unique name can be created by embedding the hash of the public key
   into the name itself.  This achieves uniqueness and is also used by
   the client to validate the server's public key Section 5.  Details on
   encoding are in Section 6.

4.  Short Host Names

   Long host names containing encoded public keys are awkward for users.
   This section describes how short names can also be advertised by
   servers and securely validated by clients, so that the short name is
   presented to users while the long name is used to actually connect.

   A server already advertising its long name using mDNS can also
   advertise its short name using mDNS.  The client needs to validate
   they are the same server, prior to allowing the user to interact with
   the short name.  The client can do this by making two connections --
   one to the long name and another to the short name and verify they
   both return the same public key and that the TLS handshake finishes
   successfully (proving the server has possession of the associated
   private key).

   The client need only look for matching short name and unique name
   within the same TLD domain name (that is, if a unique name is
   advertised with a ".local" domain, the client does not need to look
   for its accompanying short name within ".internal").

   To avoid the problems described in Section 3, the TLS data connection
   always uses the long name.  Thus, if the client has validated the
   short name as described above and a user attempts to connect to the
   short name (by typing or by some other user interaction), the client
   makes a connection to the unique name.

5.  Validation

   The client connects to a unique hostname and sends a TLS ClientHello.
   The client parses the returned certificate and extracts the public
   key and compares its hash with the hash contained in the hostname.
   If they match, the TLS session continues.  If they do not match, the
   client might warn the user about the certificate (as is common today)
   or simply abortthe TLS connection.  This requires possession of the
   associated private key to successfully complete the TLS handshake,
   preventing a rogue server from impersonating another server.

6.  Encoding Details

   The general format is hostname, a period, a digit indicating the hash
   algorithm, and then the hash of the server's public key.  The binary
   hash output is base32 encoded (Section 6 of [RFC4648]) without
   trailing "=" padding.  Currently only SHA256 hash is defined with the
   value "0" (Section 9).  While base32 encoding is specified as
   uppercase, implementations should treat uppercase, lowercase, and
   mixed case the same.

             friendly-name = 1*63(ALPHA / DIGIT / "-")

             hash-algorithm = DIGIT   ; 0=SHA256

             base32-digits = "2" / "3" / "4" / "5" / "6" / "7"

             hash = 1*62(/ ALPHA / base32-digits )
                  ; 62+1 octet limit from RFC1035

             encoded-hostname = friendly-name "."
                                hash-algorithm
                                hash

   An example encoding is shown in Appendix A.

7.  Identifying Servers as Local

   This section defines the domain names and IP addresses considered
   "local".

7.1.  Local Domain Names

   The following domain name suffixes are considered "local":

   *  ".local" (from [mDNS])

   *  ".home-arpa" (from [Homenet])

   *  ".internal" (from [I-D.davies-internal-tld])

   *  both ".localhost" and "localhost" (Section 6.3 of [RFC6761])

7.2.  Local IP Addresses

   Additionally, if any host resolves to a local IP address and
   connection is made to that address, those are also considered
   "local":

   *  10/8, 172.16/12, and 192.168/16 (from [RFC1918])

   *  169.254/16 and fe80::/10 (from [RFC3927] and [RFC4291])

   *  fc00::/7 (from [RFC4193])

   *  127/8 and ::1/128 (from [RFC990] and [RFC4291])

8.  Security Considerations

   TODO: write more on security considerations

8.1.  Rogue Servers on Local Domain

   A client may also want to defend against rogue servers installed on
   the network.  This requires legitimate servers be enrolled in such as
   by a local domain Certification Authority (e.g.,
   [I-D.sweet-iot-acme]).

8.2.  Public Key Hash

   Because the server's public key is encoded into its domain name,
   changing the public key would also change its domain name -- thus,
   its identity as known by client password managers and other
   configurations in clients (e.g., printer, SMB share, etc.).  As such
   an identity change is extremely disruptive, it needs to be avoided.
   This means the public/private key pair on a server needs to stay
   static.  The tradeoff is servers are vulnerable to their private keys
   being stolen and an active attacker intercepting traffic to that
   server.  The alternatives are to continue using unencrypted
   communication to local servers, which is vulnerable to passive
   attack, or to condition users to validate self-signed certificates
   for local servers.

9.  IANA Considerations

   New registry for hash type, 0=SHA256.  Extensions via IETF Action.

10.  References

10.1.  Normative References

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https://www.rfc-editor.org/rfc/rfc4648>.

10.2.  Informative References

   [Homenet]  Pfister, P. and T. Lemon, "Special-Use Domain
              'home.arpa.'", RFC 8375, DOI 10.17487/RFC8375, May 2018,
              <https://www.rfc-editor.org/rfc/rfc8375>.

   [I-D.davies-internal-tld]
              Davies, K. and A. McConachie, "A Top-level Domain for
              Private Use", Work in Progress, Internet-Draft, draft-
              davies-internal-tld-01, 18 October 2024,
              <https://datatracker.ietf.org/doc/html/draft-davies-
              internal-tld-01>.

   [I-D.sweet-iot-acme]
              Sweet, M., "ACME-Based Provisioning of IoT Devices", Work
              in Progress, Internet-Draft, draft-sweet-iot-acme-06, 9
              August 2024, <https://datatracker.ietf.org/doc/html/draft-
              sweet-iot-acme-06>.

   [mDNS]     Cheshire, S. and M. Krochmal, "Multicast DNS", RFC 6762,
              DOI 10.17487/RFC6762, February 2013,
              <https://www.rfc-editor.org/rfc/rfc6762>.

   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.
              J., and E. Lear, "Address Allocation for Private
              Internets", BCP 5, RFC 1918, DOI 10.17487/RFC1918,
              February 1996, <https://www.rfc-editor.org/rfc/rfc1918>.

   [RFC3927]  Cheshire, S., Aboba, B., and E. Guttman, "Dynamic
              Configuration of IPv4 Link-Local Addresses", RFC 3927,
              DOI 10.17487/RFC3927, May 2005,
              <https://www.rfc-editor.org/rfc/rfc3927>.

   [RFC4193]  Hinden, R. and B. Haberman, "Unique Local IPv6 Unicast
              Addresses", RFC 4193, DOI 10.17487/RFC4193, October 2005,
              <https://www.rfc-editor.org/rfc/rfc4193>.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, DOI 10.17487/RFC4291, February
              2006, <https://www.rfc-editor.org/rfc/rfc4291>.

   [RFC6761]  Cheshire, S. and M. Krochmal, "Special-Use Domain Names",
              RFC 6761, DOI 10.17487/RFC6761, February 2013,
              <https://www.rfc-editor.org/rfc/rfc6761>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <https://www.rfc-editor.org/rfc/rfc7250>.

   [RFC990]   Reynolds, J. and J. Postel, "Assigned numbers", RFC 990,
              DOI 10.17487/RFC0990, November 1986,
              <https://www.rfc-editor.org/rfc/rfc990>.

   [secure-context]
              W3C, "Web Platform Design Principles", June 2024,
              <https://w3ctag.github.io/design-principles/#secure-
              context>.

Appendix A.  Example Encoding

   Server with private key in PEM format is:

   -----BEGIN PRIVATE KEY-----
   MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCOkTU8TOKW/IZ6
   whhyhg+1I4u0jm019z4SVUKAwKyOtFPtoEvRGPdKYUoLaPZmVyN/VTYlubVn7dE8
   IYpibwkDhs38DKmyo0vdWjUaopQOaygtLB+PZ12l/XaSCE1cWsl45ShUvktcVR/D
   DKwv7DWEIZrRTLKy6M+8Ne4x++kKXmwbSj8WsNQ4kU4uFhS+JXHXToZvhvoQLkTs
   486XXPn4SJPLyTN62b6KHTLM1vb7RY4i4U7N6hS1UWe7bIxZNZ0vnf4vZ7A6SR7W
   nM31DoaW5XCBH7CL56MSdn7dmuksRimfNmnsEmvBXZmuQMHnUZghBLMHPC9xmHhT
   8q3pSY5jAgMBAAECggEANiAY1vDVob7zi01/HJObCQkatAzSl4drUGiAHAOKP49k
   wbV2s0bIM7vl8ZkC2u3AM0p1iTMNFQzrv+l38VD4WhdmwodIMeLfHYVu3dLVZPf3
   w9aZkMcMfcVRq7VtMV/iV3ygqDOqxr4mldWM1ZDW7HgZn9Z/jX7nxyuuZ9mcquuH
   Brl8pcUba7666jcz+F9NNjXTPCwfm7ihCPkTeYr1NflQGTR5PJ+D5dywb53iulm1
   ZTk2zBXJMujbIyTL0p+MqdEKXci7oQJqf7bQsxsO2ZUD24CmzYldsE6vmYUFxJpw
   ZbYzO/a/Mv0mXQhcUTWKkJkU78QT2Us7SuSL+IPGSQKBgQDC5iRKtlYulUgxV9gu
   TmX30R0W7R0nnsEjolNAqUwcIoUMHk8ODXEsp7jVOSFMJhHRMXL+VKYiBsiIV7vk
   GlTbLRP34HgK54auRF6PTxBfNAkF+FQxl2mzWxj7wi5mg0g+tCJTLereUXULz8+r
   h5Vqp4BCjcoumlyY0xlLtbr9/wKBgQC7Qx2Lb70XCL5eivdokMh2lRint9cfxC2W
   fJ6QOnJgsN9XIQGTUAk3cLvmrKg3UOmJXXq+Q6djVB/3Op3+TFzsGS2ORMel9r6o
   kAHYG/qdairlW9uTDsnwUP8UtE0lidhSXLGIAy71eMDbDg/c/yyrWTvysXf5kAiJ
   CzTnyvY3nQKBgBt+Va5IbH3jxyxWxQM7Qf0kfaMHTe6R4ZMCShY8C6WIZRZhjCti
   UA3JlzRU+9J/KFJHVH52OH1iUZWSMsopwMCuaju0aZq4MHKS6Hf04k1bzM4Pyui4
   AEwx1KNnMB579IwL4y+ysYgtG4LQDO6YkMZb3KcG03ehhOB2HwJkH33HAoGATOw3
   8bQ3v4OG970r/lcjEZsTYqnhA5qJg3yzgdmQbGmbhOX5CLNi5dQ4S3x3KSnilNvC
   dO/DjcjbzKnWhsSFkzKQhRV50ZH3JbTqHQT5QLqA3nCKVPFJQJ90+ONLoXTrWIHd
   J1rvakRtLE6tc4GartRcDMib2PcymmDxHZpA4/0CgYEAs0XF1G0gmnef8oEYuwZT
   c+vr4wnD7YCP1h8nsNSgRHLk1e7k727iHGvruX3qrKsY26RHKi2+i1P6A39I4F5s
   3Dme4HGXTyoc/qKp+/GAx5XYVG4c3Z3sdBejkpkhPTSlsSsDOHbjaiFV1zCyEdg5
   fOPfIBX8uLc3UtOm0+Gn1IQ=
   -----END PRIVATE KEY-----

   and public key in PEM format is:

   -----BEGIN PUBLIC KEY-----
   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjpE1PEzilvyGesIYcoYP
   tSOLtI5tNfc+ElVCgMCsjrRT7aBL0Rj3SmFKC2j2Zlcjf1U2Jbm1Z+3RPCGKYm8J
   A4bN/AypsqNL3Vo1GqKUDmsoLSwfj2ddpf12kghNXFrJeOUoVL5LXFUfwwysL+w1
   hCGa0UyysujPvDXuMfvpCl5sG0o/FrDUOJFOLhYUviVx106Gb4b6EC5E7OPOl1z5
   +EiTy8kzetm+ih0yzNb2+0WOIuFOzeoUtVFnu2yMWTWdL53+L2ewOkke1pzN9Q6G
   luVwgR+wi+ejEnZ+3ZrpLEYpnzZp7BJrwV2ZrkDB51GYIQSzBzwvcZh4U/Kt6UmO
   YwIDAQAB
   -----END PUBLIC KEY-----

   Using the binary format (DER) and hashed using SHA256 gives this hex
   value:

   21ebc0d00e98e3cb289738e2c091e532c4ad8240e0365b22067a1449693e5a18

   Converting that hex value to binary and base32 encoded (without
   trailing "=") gives:

   EHV4BUAOTDR4WKEXHDRMBEPFGLCK3ASA4A3FWIQGPIKES2J6LIMA

   After the hash algorithm identification digit (0 for SHA512/256) is
   prefixed to that base64url, resulting in:

   0EHV4BUAOTDR4WKEXHDRMBEPFGLCK3ASA4A3FWIQGPIKES2J6LIMA

   Finally, if this is a printer named "printer" advertised using
   ".local", the full FQDN for its unique name would be:

   printer.0EHV4BUAOTDR4WKEXHDRMBEPFGLCK3ASA4A3FWIQGPIKES2J6LIMA.local

   and the full FQDN for its short name would be "printer.local".

Acknowledgments

   This Internet Draft started as a document published by Martin Thomson
   in 2007.

Author's Address

   Dan Wing
   Citrix
   Email: danwing@gmail.com
